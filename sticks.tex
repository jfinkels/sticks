\documentclass{article}
\usepackage{aliascnt} % for correct autoref labeling of non-theorems
\usepackage[noend, % omit end of block tags
  noline, % omit vertical block lines
  linesnumbered, % number lines
  boxed, % put a box around the algorithm
  %oldcommands % newer versions of package have different command names
]{algorithm2e} % for creating pseudocode
\usepackage{amsfonts} % for \mathbb
\usepackage{amsmath} % for \implies
\usepackage{amsthm} % for theorems, definitions, lemmas, and styles
\usepackage{complexity}

% don't print semicolons in pseudocode algorithms
\dontprintsemicolon

% Define theorem, lemma, and definition environments and corresponding styles.
% Lemmata, corollaries, and definitions are numbered with the same counter as
% that for theorems. We have to do some black magic to get the \autoref labels
% to work correctly.
\newtheorem{theorem}{Theorem}[section]

\newaliascnt{lemma}{theorem}
\newtheorem{lemma}[lemma]{Lemma}
\aliascntresetthe{lemma}

\newaliascnt{corollary}{theorem}
\newtheorem{corollary}[corollary]{Corollary}
\aliascntresetthe{corollary}

\newaliascnt{definition}{theorem}
\theoremstyle{definition} \newtheorem{definition}[definition]{Definition}
\aliascntresetthe{definition}

% define lemma, corollary, and definition context labels for \autoref command
% (theorem is already defined)
\newcommand{\lemmaname}{Lemma}
\newcommand{\corollaryname}{Corollary}
\newcommand{\definitionname}{Definition}

\newcommand{\triple}[3]{\langle#1,#2,#3\rangle} % generalization of pairing fn.
\newcommand{\powerset}[1]{\mathcal{P}(#1)} % the power set operator

\newenvironment{langdef}[1]{\begin{definition}{\lang{#1}}}{\end{definition}}
\newenvironment{instance}{\\Instance:}{}
\newenvironment{question}{\\Question:}{}

\begin{document}
  \begin{langdef}{3USTICKS}\label{def:3usticks}
    \begin{instance}
      a finite set of symbols $\Sigma$, a finite set of sticks
      $T\subseteq\powerset{\Sigma}^3$, and $k\in\mathbb{N}$
    \end{instance}
    \begin{question}
      Does there exist a layout $c\colon\{1,\ldots,k\}\to\Sigma$ such that for
        all tiles $(X, Y, Z)\in T$, there exists a position
        $n\in\{1,\ldots,k-2\}$ such that $c(n)\in X$, $c(n+1)\in Y$ and
        $c(n+2)\in Z$.
    \end{question}
  \end{langdef}

  % TODO add ref, GJ p.237 [SS4] points to Lawler 78
  \begin{langdef}{UNITSEQUENCING}\label{def:useq}
    \begin{instance}
      a finite set of tasks $T$, a partial order $\leq$ on $T$, a length
      $\ell(t)\in\{0,1\}$ for each task $t\in T$, and $k\in\mathbb{N}$
    \end{instance}
    \begin{question}
      Does there exist a one-processor schedule for $T$, i.e. an injective
      function $\sigma\colon T\to\mathbb{Z}_0^+$, such that $t_1\leq
      t_2\implies\sigma(t_1)+\ell(t_1)\leq\sigma(t_2)$ and $\sum_{t\in
        T}{\sigma(t)+\ell(t)}\leq k$?
    \end{question}
  \end{langdef}

  % TODO reference Lawler 78
  \begin{lemma}\label{lem:useqnpc}
    \lang{UNITSEQUENCING} is \NP-complete.
  \end{lemma}
  \begin{proof}
  \end{proof}

  \begin{theorem}\label{thm:3usticksnpc}
    \lang{3USTICKS} is \NP-complete.
  \end{theorem}
  \begin{proof}
    The proof is by reduction from \lang{UNITSEQUENCING}. Construct the
    reduction as follows, given input $\langle T, \leq, \ell(t), k\rangle$.\\
    \begin{algorithm}[H]
      $k'\gets3k$\;
      $\Sigma\gets T$\;
      $T'\gets\emptyset$\;
      \For{$t\in T$}{
        $t'\gets(\{t\}, \{t\}, \{t\})$\;
        \For{$s\in T\backslash\{t\}$}{
          \If{$s\leq t$}{
            $k'\gets k'-1$\;
            $t'\gets(t'.left\cup\{s\}, t'.middle, t'.right)$\;
          }
          \If{$t\leq s$}{
            $k'\gets k'-1$\;
            $t'\gets(t'.left, t'.middle, t'.right\cup\{s\})$\;
          }
        }
        \eIf{$\ell(t)=1$}{
          $t'_{left}\gets (t'.left, t'.middle, \{t'_{mid}\})$\;
          $t'_{right}\gets(\{t'_{mid}\}, t'.middle, t'.right)$\;
          $k'\gets k'+2$\;
          $T'\gets T'\cup\{t'_{left}, t'_{right}\}$\;
        }{
          $T'\gets T'\cup\{t'\}$\;
        }
      }
      \Return{$\langle\Sigma,T',k'\rangle$}
    \end{algorithm}
  \end{proof}

\end{document}
